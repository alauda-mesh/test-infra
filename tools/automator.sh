#!/bin/bash

# Copyright (C) 2020 Red Hat, Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -e
set -u
set -o pipefail

function error() {
  echo "$@"
  exit 1
}

function trim() {
  local var="$*"

  var="${var#"${var%%[![:space:]]*}"}"
  var="${var%"${var##*[![:space:]]}"}"
  echo "${var}"
}

function usage() {
  echo "Runs a command on a given repository and commit/push the result"
  echo
  echo "Usage: $0 <options>"
  echo
  echo "Options:"
  echo -e "  -o <org>\t\t GitHub organization. Mandatory."
  echo -e "  -r <repo(s)>\t\t GitHub repository(ies), separated by comma. Mandatory."
  echo -e "  -f <oauth-token-file>\t File that contains the GitHub oauth token. Mandatory."
  echo -e "  -c <command>\t\t Command to execute to generate the diff to be committed. Mandatory."
  echo -e "  -b <branch>\t\t Branch. Defaults to the same as the original repo."
  echo -e "  -l <label>\t\t Labels (comma-separated) to add to PR."
  echo -e "  -t <title>\t\t Title of PR. "
  echo -e "  -m <modifier>\t\t Modifier (string) to append to the fork name, to differentiate it from other PR's"

  if [ -n "${1:-}" ]  ; then
    echo -e "\n${1}"
    exit 1
  fi

  exit 0
}

function split_on_commas() {
  local array
  IFS=, read -r -a array <<<"${1}"
  echo "${array[@]}"
}

function parse_args() {

  while getopts ":o:r:f:c:b:l:t:m:h" opt; do
    case ${opt} in
      o) ORG=$(trim "${OPTARG}");;
      r) REPOS=$(trim "${OPTARG}");;
      f) TOKEN_FILE=$(trim "${OPTARG}");;
      c) CMD=$(trim "${OPTARG}");;
      b) BRANCH=$(trim "${OPTARG}");;
      l) LABELS=$(trim "${OPTARG}");;
      t) TITLE=$(trim "${OPTARG}");;
      m) MODIFIER=$(trim "${OPTARG}");;
      h) usage 0;;
      *) usage "Invalid command line argument. Aborting." ;;
    esac
  done

  shift $((OPTIND -1))
  if [ $# -ne 0 ]; then
    usage "Invalid command line argument. Aborting."
  fi

  validate_args
}

function validate_args() {
  [ -z "${ORG:-}" ] && usage "Missing organization"
  [ -z "${CMD:-}" ] && usage "Missing command"
  [ -z "${TOKEN_FILE:-}" ] && usage "Missing token file"

  REPOS="$(split_on_commas "${REPOS:-}")"
  [ -z "${REPOS:-}" ] && usage "Missing repository"

  TOKEN="$(cat "${TOKEN_FILE}")"
  [ -z "${TOKEN}" ] && usage "Invalid token file"

  BRANCH="${BRANCH:-$(git symbolic-ref --quiet --short HEAD)}"
  TITLE="${TITLE:-Automator: Bump upstream}"
  MODIFIER="${MODIFIER:-automator}"

  SCRIPT_PATH="$(mktemp -t script-XXXXXXXXXX)"
  echo "${CMD}" >"${SCRIPT_PATH}"
}

function fetch_gh_data() {
  local raw
  raw=$(curl -sSfLH "Authorization: token ${TOKEN}" https://api.github.com/user)

  GH_USER=$(echo "${raw}" | jq --raw-output .login)
  GH_EMAIL=$(echo "${raw}" | jq --raw-output .email)

  if [ -z "${GH_USER}" ] || [ -z "${GH_EMAIL}" ]; then
    error "Error fetching bot's data from GitHub"
  fi
}

function create_pr() {
  local repo="${1}"
  local fork_name="${2}"

  pr-creator \
    --github-token-path="${TOKEN_FILE}" \
    --org="${ORG}" \
    --repo="${repo}" \
    --branch="${BRANCH}" \
    --title="${TITLE}" \
    --match-title="\"${TITLE}\"" \
    --body="Generated by Automator - $(date -uIseconds)" \
    --source="${GH_USER}:${fork_name}" \
    --confirm
}

function add_labels() {
  local repo="${1}"
  local pr="${2}"
  local json_labels

  if [ -n "${LABELS:-}" ]; then
    json_labels="$(echo "${LABELS}" | jq --raw-input --compact-output 'split(",")')"
    curl -XPOST -sSfLH "Authorization: token ${TOKEN}" "https://api.github.com/repos/${ORG}/${repo}/issues/${pr}/labels" --data "{\"labels\": ${json_labels}}" >/dev/null
  fi
}

function commit_and_push() {
  local repo="${1}"
  local fork_name="${2}"

  git -c "user.name=${GH_USER}" -c "user.email=${GH_EMAIL}" commit --message "${TITLE}" --author="${GH_USER} <${GH_EMAIL}>"
  git show --shortstat
  git push --force "https://${GH_USER}:${TOKEN}@github.com/${GH_USER}/${repo}.git" "HEAD:${fork_name}"
}

function do_work() {
  local pr
  local hash
  local fork_name
  local repo="${1}"
  local src_branch="${PULL_BASE_REF:-${BRANCH}}"

  # Use an unique fork name for the triple (origin repo, target repo, pr title)
  # This avoids that two or more jobs that use automator for different purposes share the same fork
  hash=$(echo -n "${TITLE}" | md5sum | cut -c1-8)
  fork_name="${src_branch}-${BRANCH}-${MODIFIER}-${hash}"

  # Create a fork
  curl -XPOST -sSfLH "Authorization: token ${TOKEN}" "https://api.github.com/repos/${ORG}/${repo}/forks" > /dev/null

  git clone --single-branch --branch "${BRANCH}" "https://github.com/${ORG}/${repo}.git"
  pushd "${repo}"

  echo "Executing ${CMD}"
  bash "${SCRIPT_PATH}"
  git add .

  if git diff --cached --quiet --exit-code; then
    echo "***"
    echo "No diff was generated for ${repo}"
    echo "***"
    return
  fi

  commit_and_push "${repo}" "${fork_name}"
  pr=$(create_pr "${repo}" "${fork_name}")
  add_labels "${repo}" "${pr}"

  popd
}

function cleanup() {
  rm -rf "${TMP_DIR:-}"
}

function current_sha() {
  git rev-parse HEAD
}

function export_globals() {
  AUTOMATOR_SHA="$(current_sha)"

  export AUTOMATOR_SHA
}

main() {
  parse_args "$@"
  fetch_gh_data
  export_globals

  TMP_DIR=$(mktemp -d)
  cd "${TMP_DIR}"
  trap cleanup EXIT

  for repo in ${REPOS}; do
    do_work "${repo}"
  done
}

main "$@"
